/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/client/lexer.ts":
/*!*****************************!*\
  !*** ./src/client/lexer.ts ***!
  \*****************************/
/*! exports provided: Lexer, LexicalGrammar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LexicalGrammar\", function() { return LexicalGrammar; });\nclass Lexer {\r\n    constructor(source, rules) {\r\n        this.source = source;\r\n        this.rules = rules;\r\n        this.position = 0;\r\n    }\r\n    peek() {\r\n        return this.peeked = this.scan();\r\n    }\r\n    match(type, raw) {\r\n        let p = this.peek();\r\n        if (p && p.type == type && (!raw || p.raw == raw)) {\r\n            this.peeked = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    scan() {\r\n        if (this.peeked) {\r\n            let res = this.peeked;\r\n            this.peeked = null;\r\n            return res;\r\n        }\r\n        var token = null;\r\n        var length = 0;\r\n        this.rules.forEach(rule => {\r\n            rule.r.lastIndex = this.position;\r\n            var x = rule.r.exec(this.source);\r\n            if (x && x[0].length > length && this.position + x[0].length == rule.r.lastIndex) {\r\n                token = rule.fn(this, x);\r\n                token.offset = this.position;\r\n                token.raw = x[0];\r\n                length = x[0].length;\r\n            }\r\n        });\r\n        this.position += length;\r\n        if (token == null) {\r\n            if (this.position == this.source.length)\r\n                return null;\r\n            throw new Error(\"Unexpected character at \" + this.position + \": \" + JSON.stringify(this.source));\r\n        }\r\n        return token;\r\n    }\r\n}\r\nclass LexicalGrammar {\r\n    constructor() {\r\n        this.rules = [];\r\n    }\r\n    terminal(pattern, fn) {\r\n        this.rules.push({ r: new RegExp(pattern, \"g\"), fn: fn });\r\n    }\r\n    lex(source) {\r\n        return new Lexer(source, this.rules);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/client/lexer.ts?");

/***/ }),

/***/ "./src/client/main.ts":
/*!****************************!*\
  !*** ./src/client/main.ts ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ \"./src/client/lexer.ts\");\n\r\nlet toplevel = new _lexer__WEBPACK_IMPORTED_MODULE_0__[\"LexicalGrammar\"]();\r\ntoplevel.terminal(\"[\\\\s,]+\", (l, m) => ({ type: \"ws\" }));\r\ntoplevel.terminal(\";.*\", (l, m) => ({ type: \"comment\" }));\r\ntoplevel.terminal(\"\\\\(|\\\\[|\\\\{|#\\\\(|#?\\\\(|#\\\\{|#?@\\\\(\", (l, m) => ({ type: \"open\" }));\r\ntoplevel.terminal(\"\\\\)|\\\\]|\\\\}\", (l, m) => ({ type: \"close\" }));\r\ntoplevel.terminal(\"~@|~|'|#'|#:|#_|\\\\^|`|#|\\\\^:\", (l, m) => ({ type: \"punc\" }));\r\ntoplevel.terminal(\"true|false|nil\", (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(\"[0-9]+[rR][0-9a-zA-Z]+\", (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(\"[-+]?[0-9]+(\\\\.[0-9]+)?([eE][-+]?[0-9]+)?\", (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(\":[^()[\\\\]\\\\{\\\\}#,~@'`^\\\"\\\\s;]*\", (l, m) => ({ type: \"kw\" }));\r\ntoplevel.terminal(\"[^()[\\\\]\\\\{\\\\}#,~@'`^\\\"\\\\s:;][^()[\\\\]\\\\{\\\\}#,~@'`^\\\"\\\\s;]*\", (l, m) => ({ type: \"id\" }));\r\ntoplevel.terminal('\"([^\"\\\\\\\\]|\\\\\\\\.)*\"?', (l, m) => ({ type: \"str\" }));\r\ntoplevel.terminal('.', (l, m) => ({ type: \"junk\" }));\r\nconst canvas = document.createElement(\"canvas\");\r\nlet ctx = canvas.getContext(\"2d\");\r\nfunction measureText(str) {\r\n    return ctx.measureText(str).width;\r\n}\r\nlet macros = new Set([\"if\", \"let\", \"do\", \"while\", \"cond\", \"case\"]);\r\nfunction makeToken(tk) {\r\n    let span = document.createElement(\"span\");\r\n    let className = tk.type;\r\n    if (tk.type == \"id\") {\r\n        if (tk.raw.startsWith(\"def\"))\r\n            className = \"decl\";\r\n        else if (macros.has(tk.raw))\r\n            className = \"macro\";\r\n    }\r\n    span.textContent = tk.raw;\r\n    span.className = className;\r\n    return span;\r\n}\r\nclass ReplLine {\r\n    constructor(text) {\r\n        this.text = text;\r\n        this.tokens = [];\r\n    }\r\n}\r\nclass UndoStep {\r\n}\r\nclass EditorUndoStep extends UndoStep {\r\n    constructor(name, selectionStart, selectionEnd) {\r\n        super();\r\n        this.name = name;\r\n        this.selectionStart = selectionStart;\r\n        this.selectionEnd = selectionEnd;\r\n    }\r\n    undo(c) {\r\n        [c.cursorStart, c.cursorEnd] = this.selectionStart;\r\n    }\r\n    redo(c) {\r\n        [c.cursorStart, c.cursorEnd] = this.selectionEnd;\r\n    }\r\n}\r\nclass EditorInsertUndoStep extends EditorUndoStep {\r\n    constructor(name, selectionStart, selectionEnd, offset, insertedText) {\r\n        super(name, selectionStart, selectionEnd);\r\n        this.offset = offset;\r\n        this.insertedText = insertedText;\r\n    }\r\n    undo(c) {\r\n        c.model.deleteRange(this.offset, this.insertedText.length);\r\n        super.undo(c);\r\n    }\r\n    redo(c) {\r\n        c.model.insertString(this.offset, this.insertedText);\r\n        super.redo(c);\r\n    }\r\n}\r\nclass EditorDeleteUndoStep extends EditorUndoStep {\r\n    constructor(name, selectionStart, selectionEnd, offset, deletedText) {\r\n        super(name, selectionStart, selectionEnd);\r\n        this.offset = offset;\r\n        this.deletedText = deletedText;\r\n    }\r\n    undo(c) {\r\n        c.model.insertString(this.offset, this.deletedText);\r\n        super.undo(c);\r\n    }\r\n    redo(c) {\r\n        c.model.deleteRange(this.offset, this.deletedText.length);\r\n        super.redo(c);\r\n    }\r\n}\r\nclass LineInputModel {\r\n    constructor() {\r\n        this.lines = [new ReplLine(\"\")];\r\n        this.changedLines = new Set();\r\n        this.insertedLines = new Set();\r\n        this.deletedLines = new Set();\r\n    }\r\n    getOffsetForLine(line) {\r\n        let max = 0;\r\n        for (let i = 0; i < line; i++)\r\n            max += this.lines[i].text.length + 1;\r\n        return max;\r\n    }\r\n    getText(start, end) {\r\n        let st = this.getRowCol(Math.min(start, end));\r\n        let en = this.getRowCol(Math.max(start, end));\r\n        let lines = [];\r\n        lines[0] = this.lines[st[0]].text.substr(Math.min(start, end) - this.getOffsetForLine(st[0]));\r\n        for (let i = st[0] + 1; i < en[0]; i++)\r\n            lines.push(this.lines[i].text);\r\n        lines.push(this.lines[en[0]].text.substr(0, Math.max(start, end) - this.getOffsetForLine(en[0])));\r\n        return lines.join('\\n');\r\n    }\r\n    getRowCol(offset) {\r\n        for (let i = 0; i < this.lines.length; i++) {\r\n            if (offset > this.lines[i].text.length)\r\n                offset -= this.lines[i].text.length + 1;\r\n            else\r\n                return [i, offset];\r\n        }\r\n        return [this.lines.length - 1, this.lines[this.lines.length - 1].text.length];\r\n    }\r\n    insertString(offset, text) {\r\n        let [row, col] = this.getRowCol(offset);\r\n        let lines = text.split(/\\r\\n|\\n/);\r\n        let count = 0;\r\n        if (lines.length == 1) {\r\n            this.lines[row].text = this.lines[row].text.substring(0, col) + text + this.lines[row].text.substring(col);\r\n            count += text.length;\r\n        }\r\n        else {\r\n            let rhs = this.lines[row].text.substring(col);\r\n            this.lines[row].text = this.lines[row].text.substring(0, col) + lines[0];\r\n            let newItems = [];\r\n            for (let i = 1; i < lines.length - 1; i++) {\r\n                newItems.push(new ReplLine(lines[i]));\r\n            }\r\n            newItems.push(new ReplLine(lines[lines.length - 1] + rhs));\r\n            for (let i = 0; i < lines.length; i++)\r\n                count += lines[i].length + 1;\r\n            this.insertedLines.add([row, lines.length - 1]);\r\n            this.lines.splice(row + 1, 0, ...newItems);\r\n            count--;\r\n        }\r\n        for (let i = 0; i < lines.length; i++)\r\n            this.changedLines.add(row + i);\r\n        return count;\r\n    }\r\n    deleteRange(offset, length) {\r\n        let [row, col] = length > 0 ? this.getRowCol(offset) : this.getRowCol(offset + length);\r\n        let [endRow, endCol] = length > 0 ? this.getRowCol(offset + length) : this.getRowCol(offset);\r\n        if (endRow != row) {\r\n            let left = this.lines[row].text.substring(0, col);\r\n            let right = this.lines[endRow].text.substring(endCol);\r\n            this.lines[row].text = left + right;\r\n            this.lines.splice(row + 1, endRow - row);\r\n            this.changedLines.add(row);\r\n            this.deletedLines.add([row + 1, endRow - row]);\r\n        }\r\n        else {\r\n            this.lines[row].text = this.lines[row].text.substring(0, col) + this.lines[row].text.substring(col + length);\r\n            this.changedLines.add(row);\r\n        }\r\n    }\r\n    get maxOffset() {\r\n        let max = 0;\r\n        for (let i = 0; i < this.lines.length; i++)\r\n            max += this.lines[i].text.length + 1;\r\n        return max - 1;\r\n    }\r\n}\r\nclass UndoManager {\r\n    constructor() {\r\n        this.undos = [];\r\n        this.redos = [];\r\n    }\r\n    addUndoStep(step) {\r\n        this.undos.push(step);\r\n        this.redos = [];\r\n    }\r\n    undo(c) {\r\n        if (this.undos.length) {\r\n            const step = this.undos.pop();\r\n            step.undo(c);\r\n            this.redos.push(step);\r\n        }\r\n    }\r\n    redo(c) {\r\n        if (this.redos.length) {\r\n            const step = this.redos.pop();\r\n            step.redo(c);\r\n            this.undos.push(step);\r\n        }\r\n    }\r\n}\r\nclass ReplConsole {\r\n    constructor(mainElem) {\r\n        this.mainElem = mainElem;\r\n        this._cursorStart = 0;\r\n        this.undoManager = new UndoManager();\r\n        this._cursorEnd = 0;\r\n        this.lastCursorStart = 0;\r\n        this.lastCursorEnd = 0;\r\n        this.model = new LineInputModel();\r\n        this.inputLines = [];\r\n        this.caretX = 0;\r\n        this.mouseDrag = (e) => {\r\n            this.cursorEnd = this.positionToOffset(e.pageX, e.pageY);\r\n            this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n            this.updateState();\r\n        };\r\n        this.mouseUp = (e) => {\r\n            window.removeEventListener(\"mousemove\", this.mouseDrag);\r\n            window.removeEventListener(\"mouseup\", this.mouseUp);\r\n        };\r\n        this.mainElem.addEventListener(\"mousedown\", e => {\r\n            e.preventDefault();\r\n            this.cursorStart = this.cursorEnd = this.positionToOffset(e.pageX, e.pageY);\r\n            this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n            this.updateState();\r\n            window.addEventListener(\"mousemove\", this.mouseDrag);\r\n            window.addEventListener(\"mouseup\", this.mouseUp);\r\n        });\r\n        this.caret = document.createElement(\"div\");\r\n        this.caret.className = \"caret\";\r\n        let line = this.makeLine();\r\n        this.inputLines.push(line);\r\n        this.mainElem.appendChild(line);\r\n        ctx.font = getComputedStyle(line).font + \"\";\r\n        this.caret.style.width = measureText(\"M\") + \"px\";\r\n        line.appendChild(this.caret);\r\n    }\r\n    get cursorStart() {\r\n        return this._cursorStart;\r\n    }\r\n    ;\r\n    set cursorStart(val) {\r\n        this._cursorStart = Math.min(this.model.maxOffset, Math.max(val, 0));\r\n    }\r\n    get cursorEnd() {\r\n        return this._cursorEnd;\r\n    }\r\n    ;\r\n    set cursorEnd(val) {\r\n        this._cursorEnd = Math.min(this.model.maxOffset, Math.max(val, 0));\r\n    }\r\n    insertString(text) {\r\n        if (this.cursorStart != this.cursorEnd) {\r\n            this.deleteSelection();\r\n        }\r\n        let [cs, ce] = [this.cursorStart, this.cursorEnd];\r\n        let offset = this.cursorStart = this.cursorEnd;\r\n        this.cursorEnd += this.model.insertString(this.cursorEnd, text);\r\n        this.cursorStart = this.cursorEnd;\r\n        this.undoManager.addUndoStep(new EditorInsertUndoStep(\"Insert\", [cs, ce], [this.cursorStart, this.cursorEnd], offset, text));\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretLeft(clear = true) {\r\n        if (clear && this.cursorStart != this.cursorEnd) {\r\n            if (this.cursorStart < this.cursorEnd)\r\n                this.cursorEnd = this.cursorStart;\r\n            else\r\n                this.cursorStart = this.cursorEnd;\r\n        }\r\n        else {\r\n            this.cursorEnd--;\r\n            if (clear)\r\n                this.cursorStart = this.cursorEnd;\r\n        }\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretRight(clear = true) {\r\n        if (clear && this.cursorStart != this.cursorEnd) {\r\n            if (this.cursorStart > this.cursorEnd)\r\n                this.cursorEnd = this.cursorStart;\r\n            else\r\n                this.cursorStart = this.cursorEnd;\r\n        }\r\n        else {\r\n            this.cursorEnd++;\r\n            if (clear)\r\n                this.cursorStart = this.cursorEnd;\r\n        }\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretHomeAll(clear = true) {\r\n        this.cursorEnd = 0;\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretEndAll(clear = true) {\r\n        this.cursorEnd = this.model.maxOffset;\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretHome(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.cursorEnd);\r\n        this.cursorEnd = this.cursorEnd - col;\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretEnd(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.cursorEnd);\r\n        this.cursorEnd = this.cursorEnd - col + this.model.lines[row].text.length;\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    caretUp(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.cursorEnd);\r\n        if (row > 0) {\r\n            let len = this.model.lines[row - 1].text.length;\r\n            this.cursorEnd = this.model.getOffsetForLine(row - 1) + Math.min(this.caretX, len);\r\n        }\r\n        else {\r\n            this.cursorEnd = 0;\r\n        }\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n    }\r\n    caretDown(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.cursorEnd);\r\n        if (row < this.model.lines.length - 1) {\r\n            let len = this.model.lines[row + 1].text.length;\r\n            this.cursorEnd = this.model.getOffsetForLine(row + 1) + Math.min(this.caretX, len);\r\n        }\r\n        else {\r\n            this.cursorEnd = this.model.maxOffset;\r\n        }\r\n        if (clear)\r\n            this.cursorStart = this.cursorEnd;\r\n        this.updateState();\r\n    }\r\n    deleteSelection() {\r\n        if (this.cursorStart != this.cursorEnd) {\r\n            this.model.deleteRange(Math.min(this.cursorStart, this.cursorEnd), Math.max(this.cursorStart, this.cursorEnd) - Math.min(this.cursorStart, this.cursorEnd));\r\n            this.cursorStart = this.cursorEnd = Math.min(this.cursorStart, this.cursorEnd);\r\n        }\r\n    }\r\n    backspace() {\r\n        if (this.cursorStart != this.cursorEnd) {\r\n            this.deleteSelection();\r\n        }\r\n        else {\r\n            if (this.cursorEnd > 0) {\r\n                this.model.deleteRange(this.cursorEnd - 1, 1);\r\n                this.cursorEnd--;\r\n            }\r\n            this.cursorStart = this.cursorEnd;\r\n        }\r\n        this.updateState();\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n    }\r\n    delete() {\r\n        if (this.cursorStart != this.cursorEnd) {\r\n            this.deleteSelection();\r\n        }\r\n        else {\r\n            this.model.deleteRange(this.cursorEnd, 1);\r\n            this.cursorStart = this.cursorEnd;\r\n        }\r\n        this.caretX = this.model.getRowCol(this.cursorEnd)[1];\r\n        this.updateState();\r\n    }\r\n    makeSelection(start, width) {\r\n        let div = document.createElement(\"div\");\r\n        div.className = \"sel-marker\";\r\n        let left = start;\r\n        div.style.left = left + \"px\";\r\n        div.style.width = width + \"px\";\r\n        return div;\r\n    }\r\n    updateState() {\r\n        for (let [start, count] of this.model.insertedLines) {\r\n            for (let j = 0; j < count; j++) {\r\n                let line = this.makeLine();\r\n                if (!this.inputLines[start + j + 1])\r\n                    this.mainElem.append(line);\r\n                else\r\n                    this.mainElem.insertBefore(line, this.inputLines[start + j + 1]);\r\n                this.inputLines.splice(start + j + 1, 0, line);\r\n            }\r\n        }\r\n        this.model.insertedLines.clear();\r\n        for (let [start, count] of this.model.deletedLines) {\r\n            for (let j = 0; j < count; j++)\r\n                this.mainElem.removeChild(this.inputLines[start + j]);\r\n            this.inputLines.splice(start, count);\r\n        }\r\n        this.model.deletedLines.clear();\r\n        for (let line of this.model.changedLines) {\r\n            let ln = this.inputLines[line].querySelector(\".content\");\r\n            while (ln.firstChild)\r\n                ln.removeChild(ln.firstChild);\r\n            let lex = toplevel.lex(this.model.lines[line].text);\r\n            for (;;) {\r\n                let tk = lex.scan();\r\n                if (!tk)\r\n                    break;\r\n                ln.appendChild(makeToken(tk));\r\n            }\r\n            if (!ln.firstChild)\r\n                ln.appendChild(document.createTextNode(\" \"));\r\n        }\r\n        this.model.changedLines.clear();\r\n        let [row, col] = this.model.getRowCol(this.cursorEnd);\r\n        this.inputLines[row].appendChild(this.caret);\r\n        this.caret.style.left = measureText(this.model.lines[row].text.substr(0, col)) + \"px\";\r\n        let startLine = this.model.getRowCol(Math.min(this.lastCursorStart, this.lastCursorEnd, this.cursorStart, this.cursorEnd));\r\n        let endLine = this.model.getRowCol(Math.max(this.lastCursorStart, this.lastCursorEnd, this.cursorStart, this.cursorEnd));\r\n        let cs = this.model.getRowCol(Math.min(this.cursorStart, this.cursorEnd));\r\n        let ce = this.model.getRowCol(Math.max(this.cursorStart, this.cursorEnd));\r\n        let lcs = this.model.getRowCol(Math.min(this.lastCursorStart, this.lastCursorEnd));\r\n        let lce = this.model.getRowCol(Math.max(this.lastCursorStart, this.lastCursorEnd));\r\n        for (let line = startLine[0]; line <= endLine[0]; line++) {\r\n            let ln = this.inputLines[line].querySelector(\".selection\");\r\n            if (line < cs[0] || line > ce[0]) {\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n            }\r\n            else if (line == cs[0] && line == ce[0]) {\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                let left = measureText(\"M\") * cs[1];\r\n                ln.appendChild(this.makeSelection(left, measureText(\"M\") * ce[1] - left));\r\n            }\r\n            else if (line == cs[0]) {\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                let left = measureText(\"M\") * cs[1];\r\n                ln.appendChild(this.makeSelection(left, measureText(\"M\") * this.model.lines[line].text.length - left));\r\n            }\r\n            else if (line == ce[0]) {\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                ln.appendChild(this.makeSelection(0, measureText(\"M\") * ce[1]));\r\n            }\r\n            else if (line > cs[0] && line < ce[0]) {\r\n                if (line > lcs[0] && line < lce[0]) {\r\n                }\r\n                else if (line >= cs[0] && line <= ce[0]) {\r\n                    while (ln.firstChild)\r\n                        ln.removeChild(ln.firstChild);\r\n                    ln.appendChild(this.makeSelection(0, Math.max(measureText(\"M\"), measureText(\"M\") * this.model.lines[line].text.length)));\r\n                }\r\n                else {\r\n                    while (ln.firstChild)\r\n                        ln.removeChild(ln.firstChild);\r\n                }\r\n            }\r\n        }\r\n        this.lastCursorStart = this.cursorStart;\r\n        this.lastCursorEnd = this.cursorEnd;\r\n    }\r\n    positionToOffset(pageX, pageY) {\r\n        let rect = this.mainElem.getBoundingClientRect();\r\n        let y = pageY - rect.top;\r\n        let i;\r\n        for (i = 0; i < this.mainElem.children.length; i++) {\r\n            let child = this.mainElem.children.item(i);\r\n            if (y < child.offsetTop)\r\n                break;\r\n        }\r\n        i--;\r\n        let offset = this.model.getOffsetForLine(i);\r\n        offset += Math.min(Math.floor((pageX - rect.left) / measureText(\"M\")), this.model.lines[i].text.length);\r\n        return offset;\r\n    }\r\n    makeLine() {\r\n        let line = document.createElement(\"div\");\r\n        line.className = \"line\";\r\n        let content = document.createElement(\"div\");\r\n        content.className = \"content\";\r\n        line.append(content);\r\n        let selection = document.createElement(\"div\");\r\n        selection.className = \"selection\";\r\n        line.append(selection);\r\n        return line;\r\n    }\r\n}\r\nwindow.addEventListener(\"keydown\", e => {\r\n    if (e.key.length == 1 && !e.ctrlKey) {\r\n        replMain.insertString(e.key);\r\n    }\r\n    else if (e.key.length == 1) {\r\n        switch (e.key) {\r\n            case \"a\":\r\n                replMain.cursorStart = 0;\r\n                replMain.cursorEnd = replMain.model.maxOffset;\r\n                replMain.updateState();\r\n                e.preventDefault();\r\n                break;\r\n            case 'z':\r\n                replMain.undoManager.undo(replMain);\r\n                replMain.updateState();\r\n                break;\r\n            case 'Z':\r\n                replMain.undoManager.redo(replMain);\r\n                replMain.updateState();\r\n                break;\r\n        }\r\n    }\r\n    else {\r\n        switch (e.keyCode) {\r\n            case 9:\r\n                e.preventDefault();\r\n                break;\r\n            case 13:\r\n                replMain.insertString(\"\\n\");\r\n                break;\r\n            case 37:\r\n                replMain.caretLeft(!e.shiftKey);\r\n                break;\r\n            case 39:\r\n                replMain.caretRight(!e.shiftKey);\r\n                break;\r\n            case 8:\r\n                replMain.backspace();\r\n                break;\r\n            case 36:\r\n                if (e.ctrlKey)\r\n                    replMain.caretHomeAll(!e.shiftKey);\r\n                else\r\n                    replMain.caretHome(!e.shiftKey);\r\n                break;\r\n            case 35:\r\n                if (e.ctrlKey)\r\n                    replMain.caretEndAll(!e.shiftKey);\r\n                else\r\n                    replMain.caretEnd(!e.shiftKey);\r\n                break;\r\n            case 38:\r\n                replMain.caretUp(!e.shiftKey);\r\n                break;\r\n            case 40:\r\n                replMain.caretDown(!e.shiftKey);\r\n                break;\r\n            case 46:\r\n                replMain.delete();\r\n                break;\r\n        }\r\n    }\r\n});\r\nlet replMain = new ReplConsole(document.getElementById(\"repl\"));\r\ndocument.addEventListener(\"cut\", e => {\r\n    e.clipboardData.setData(\"text/plain\", replMain.model.getText(replMain.cursorStart, replMain.cursorEnd));\r\n    replMain.delete();\r\n    e.preventDefault();\r\n});\r\ndocument.addEventListener(\"copy\", e => {\r\n    e.clipboardData.setData(\"text/plain\", replMain.model.getText(replMain.cursorStart, replMain.cursorEnd));\r\n    e.preventDefault();\r\n});\r\ndocument.addEventListener(\"paste\", e => {\r\n    replMain.insertString(e.clipboardData.getData(\"text/plain\"));\r\n    console.log(\"Pasted \" + e.clipboardData.getData(\"text/plain\"));\r\n    e.preventDefault();\r\n});\r\n\n\n//# sourceURL=webpack:///./src/client/main.ts?");

/***/ })

/******/ });